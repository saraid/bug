#!/usr/bin/env ruby

require 'rubygems'
require 'active_resource'
require 'yaml'

COLOR = {
    :clear => "\e[0m",
    :red => "\e[#31m",
    :green => "\e[#32m",
    :yellow => "\e[#33m",
    :blue => "\e[#34m",
    :magenta => "\e[#35m",
    :cyan => "\e[#36m"
    }

CONFIG_FILE = "#{Dir.home}/.bugsrc"
DIRECTORY = "#{Dir.home}/.bugs"

# Migrate from .bugs file to .bugs directory.
if File.exists?(DIRECTORY) && File.ftype(DIRECTORY) == 'file'
  ids = File.open(DIRECTORY, 'r') do |f| f.readlines.collect { |line| line.chomp } end
  File.delete DIRECTORY
end
Dir.mkdir DIRECTORY unless Dir.exist? DIRECTORY
ids.each do |id|
  File.new("#{DIRECTORY}/#{id}", 'w')
end unless ids.nil?

command = ARGV.shift
File.open(CONFIG_FILE, 'w') do |f| f.write(YAML.dump({ :user => ARGV[0], :password => ARGV[1], :site => ARGV[2] })) end and exit if command == 'config'

$config = begin
  YAML.load_file(CONFIG_FILE)
rescue Errno::ENOENT
  puts "You don't have a user/pass configured. Use \"bug config [user] [pass] [site]\""
  exit
end

class Issue < ActiveResource::Base
  self.site = $config[:site]
  self.user = $config[:user]
  self.password = $config[:password]

  def self.list
    @@list if defined? @@list
    @@list = Dir.entries(DIRECTORY)
    2.times do @@list.shift end
    @@list
  end

  def formatted_status
    color = case status.name
      when 'New'
        :red
      when 'Needs Repro'
        :cyan
      when 'In Progress'
        :red
      when 'Resolved'
        :green
      when 'Closed'
        :green
      when 'Will Not Fix'
        :green
    end
    "#{COLOR[color]}#{"%12s" % status.name}#{COLOR[:clear]}"
  end

  def change_status status_id, notes
    self.status_id = status_id
    self.notes = notes if notes
    self.save
  end
end


case command
when 'open'
  ARGV.each do |id| IO.popen("open #{Issue.site}/issues/#{id}") end
when 'status'
  Issue.list.each do |id|
    issue = Issue.find(id.to_i, :params => { :include => 'journals' })
    puts "#{issue.id} #{"%2d" % issue.journals.length} #{"%6s" % issue.priority.name} #{issue.formatted_status} #{issue.subject}"
  end
when 'add'
  ARGV.reject { |id| Issue.list.include? id }.each { |id| File.new("#{DIRECTORY}/#{id}", 'w') }
when 'remove'
  ARGV.each { |id| File.delete("#{DIRECTORY}/#{id}") }
when 'clear'
  Issue.list.each { |id| File.delete("#{DIRECTORY}/#{id}") }
when 'fixed'
  id = ARGV[0].to_i
  pushed_upstream = IO.popen("git log --grep \"BUG.*#{id}:\" --oneline origin/master") do |f| f.readlines.length > 0 end
  puts "#{COLOR[:red]}WARNING#{COLOR[:clear]}: Change not pushed upstream. Don't forget again." unless pushed_upstream
  issue = Issue.find(id).change_status 3, ARGV[1]
when 'repro'
  issue = Issue.find(ARGV[0].to_i).change_status 1, ARGV[1]
when 'later'
  issue = Issue.find(ARGV[0].to_i).change_status 2, ARGV[1]
when 'nofix'
  issue = Issue.find(ARGV[0].to_i).change_status 6, ARGV[1]
end
