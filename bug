#!/usr/bin/env ruby

require 'rubygems'
require 'active_resource'
require 'yaml'

COLOR = {
    :clear => "\e[0m",
    :red => "\e[#31m",
    :green => "\e[#32m",
    :yellow => "\e[#33m",
    :blue => "\e[#34m",
    :magenta => "\e[#35m",
    :cyan => "\e[#36m"
    }

PRIORITY = ['Low', 'Normal', 'High', 'Urgent']

CONFIG_FILE = "#{Dir.home}/.bugsrc"
DIRECTORY = "#{Dir.home}/.bugs"

Dir.mkdir DIRECTORY rescue Errno::EEXIST

command = ARGV.shift
File.open(CONFIG_FILE, 'w') do |f| f.write(YAML.dump({ :user => ARGV[0], :password => ARGV[1], :site => ARGV[2], :user_id => ARGV[3] })) end and exit if command == 'config'

$config = begin
  YAML.load_file(CONFIG_FILE)
rescue Errno::ENOENT
  puts "You don't have a user/pass configured. Use \"bug config [user] [pass] [site]\""
  exit
end
$config[:user_id] ||= 18 # HACK FIXME

EDITOR = $config[:editor] || 'vi'

module FormattedStatus
  def formatted_status
    color = case status.name
      when 'New'
        :red
      when 'Needs Repro'
        :cyan
      when 'In Progress'
        :red
      when 'Resolved'
        :green
      when 'Closed'
        :green
      when 'Will Not Fix'
        :green
    end
    "#{COLOR[color]}#{"%12s" % status.name}#{COLOR[:clear]}"
  end
end

class Issue < ActiveResource::Base
  self.site = $config[:site]
  self.user = $config[:user]
  self.password = $config[:password]
  self.format = ActiveResource::Formats::XmlFormat
end

class Issue
  include FormattedStatus

  def initialize *args
    super(*args)
    ensure_tracked!

    @last_updated = Time.parse updated_on
    configure({ :last_updated => last_updated, :priority => priority.name, :journal_length => (respond_to?(:journals) ? journals : []).length })
    configure({ :subject => subject, :status => status.name, :id => id })
    @settings = YAML.load_file(path 'meta') || {}
  end
  attr_reader :last_updated

  def change_status status_id, notes
    self.status_id = status_id
    self.notes = notes if notes
    self.save
  end

  def to_s
    "#{self.id} #{"%2s" % (self.respond_to?(:journals) ? self.journals : []).length} #{"%6s" % self.priority.name} #{self.formatted_status} #{self.subject}"
  end

  def self.fetch
    Issue.find(:all, :params => { :assigned_to_id => 18, :sort => 'priority:desc', :include => 'journals' })
  end

  def self.destroy id
    Dir.foreach("#{DIRECTORY}/#{id}") do |filename|
      next if filename =~ /\./
      File.delete(filename)
    end
  end

  protected
  def since_updated
    Time.now - last_updated
  end

  def path file = nil
    [DIRECTORY, id, file].compact.join('/')
  end

  def ensure_tracked!
    Dir.mkdir path rescue Errno::EEXIST
    system("touch #{path 'notes'}")
    system("touch #{path 'meta'}")
  end

  def configure new_settings
    ensure_tracked!
    @settings = YAML.load_file(path 'meta') || {}
    @settings.merge! new_settings
    File.open(path('meta'), 'w') do |f| f.write(YAML.dump(@settings)) end
  end
end

module Util
  def self.fix_json json, name
    json = json[name]
    return json unless json.is_a? Hash
    json.keys.each do |key|
      json[key] = fix_json json[key], key if json[key].respond_to?(:has_key?) && json[key].has_key?(key)
    end
    json
  end

  def self.attributize hash
    return hash unless hash.is_a? Hash
    hash.keys.each do |key|
      (class << hash; self; end).class_eval do
        define_method key.to_sym do
          hash[key]
        end
      end
      Util.attributize hash[key]
    end
    hash
  end
end

class TodoList < Array
  FILENAME = "#{Dir.home}/.bugs/.todo"

  @@singleton = TodoList.new
  def self.to_a
    @@singleton
  end

  def initialize
    system("touch #{FILENAME}")
    File.open(FILENAME, 'r') { |f| (f.readlines.first || '').split(',') }.each do |id|
      self << id
    end
  end

  def <<(bug)
    bug = bug.id if bug.is_a? Issue # ?
    super(bug)
    self.uniq!
  end

  def save!
    File.open(FILENAME, 'w') do |f| f.write(self.join(',')) end
  end
end

case command
when 'open'
  ARGV.each do |id| system("open #{Issue.site}/issues/#{id}") end
when 'fetch'
  Issue.fetch
when 'status'
when 'add'
  ARGV.each { |id| Issue.find(id) }
when 'remove'
  ARGV.each { |id| Issue.destroy id }
when 'clean'
  #Issue.list.each { |id| File.delete("#{DIRECTORY}/#{id}") if (Issue.load(id) || Issue.find(id)).status.name == 'Closed' }
when 'clear'
  #Issue.list.each { |id| File.delete("#{DIRECTORY}/#{id}") }
when 'fixed'
  Issue.find(ARGV[0].to_i).fixed! ARGV[1]
when 'repro'
  Issue.find(ARGV[0].to_i).repro! ARGV[1]
when 'later'
  Issue.find(ARGV[0].to_i).later! ARGV[1]
when 'nofix'
  Issue.find(ARGV[0].to_i).nofix! ARGV[1]
end

# Commands:
# - fetch / pull / update: Get a new list from the server.
# - todo?: List all todo items, in todo priority.
# - next?: Return with the next bug to fix.
# - status: List of all tracked bugs, with summaries.
# - filter / category: Same as status, except by category.
# - clear: Untrack all bugs.
# - clean: Untrack all Closed bugs.
# - track / add: (List) Serialize and add to status list.
# - untrack / remove: (List) Remove from status list.

# Bug-level commands:
# - annotate / note: Add a personal note locally.
# - edit: Edit the local personal note.
# - categorize: Set a local categorization.
# - fixed / nofix / repro / later / comment: Update server with new information.
# - todo / enqueue: Add to local todo list.
# - important / unimportant: Located at top of status list.
# - ignore / unignore: Ignored bugs are never Todo and located at the bottom of the status list.
# - postpone: Push a bug downwards.
# - open: Open the Redmine page.
# - info / journals: Display all journals.

# Todo List priority:
# - Marked important locally.
# - Enqueued to Todo List.
# - Prioritized as Urgent / High.
# - Marked  as Severe / Major.
# - Most Journal entries.
# - Most recently updated.

class Issue
  def todo_priority
    priorities = []
    priorities << (@settings[:important] ? 1 : 0)
    priorities << (TodoList.to_a.include?(self.id) ? 1 : 0)
    priorities << self.priority.id
    #priorities << self.custom_fields.first.id # Severity
    priorities << (respond_to?(:journals) ? self.journals : []).length
    priorities << Math.log10(since_updated)

    multiplier = 1
    priorities.reverse.inject(0) do |memo, num|
      multiplier *= 100
      memo += num.to_f * multiplier
    end
  end

  def track!
    configure({ :tracking => true })
  end

  def untrack!
    configure({ :tracking => false })
  end

  def annotate notes
    ensure_tracked!
    File.open(path('notes'), 'a') do |f| f.puts(notes) end
  end

  def edit!
    ensure_tracked!
    system("#{EDITOR} #{path 'notes'}")
  end

  def categorize! category
    configure({ :category => category })
  end

  def important! toggle
    configure({ :important => toggle })
  end

  def ignore! toggle
    configure({ :ignore => toggle })
  end

  def comment! notes
    self.notes = notes
    self.save
  end

  def fixed! notes
    change_status 3, notes
    pushed_upstream = IO.popen("git log --grep \"BUG.*#{id}:\" --oneline origin/master") do |f| f.readlines.length > 0 end
    puts "#{COLOR[:red]}WARNING#{COLOR[:clear]}: Bug #{id} not pushed upstream. Don't forget again." unless pushed_upstream
  end

  def repro! notes
    change_status 1, notes
  end

  def later! notes
    change_status 2, notes
  end

  def nofix! notes
    change_status 6, notes
  end
end
