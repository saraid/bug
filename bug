#!/usr/bin/env ruby

require 'rubygems'
require 'active_resource'
require 'yaml'

COLOR = {
    :clear => "\e[0m",
    :red => "\e[#31m",
    :green => "\e[#32m",
    :yellow => "\e[#33m",
    :blue => "\e[#34m",
    :magenta => "\e[#35m",
    :cyan => "\e[#36m"
    }

PRIORITY = ['Low', 'Normal', 'High', 'Urgent']

CONFIG_FILE = "#{Dir.home}/.bugsrc"
DIRECTORY = "#{Dir.home}/.bugs"

# Migrate from .bugs file to .bugs directory.
if File.exists?(DIRECTORY) && File.ftype(DIRECTORY) == 'file'
  ids = File.open(DIRECTORY, 'r') do |f| f.readlines.collect { |line| line.chomp } end
  File.delete DIRECTORY
end
Dir.mkdir DIRECTORY unless Dir.exist? DIRECTORY
ids.each do |id|
  File.new("#{DIRECTORY}/#{id}", 'w')
end unless ids.nil?

command = ARGV.shift
File.open(CONFIG_FILE, 'w') do |f| f.write(YAML.dump({ :user => ARGV[0], :password => ARGV[1], :site => ARGV[2] })) end and exit if command == 'config'

$config = begin
  YAML.load_file(CONFIG_FILE)
rescue Errno::ENOENT
  puts "You don't have a user/pass configured. Use \"bug config [user] [pass] [site]\""
  exit
end

module FormattedStatus
  def formatted_status
    color = case status.name
      when 'New'
        :red
      when 'Needs Repro'
        :cyan
      when 'In Progress'
        :red
      when 'Resolved'
        :green
      when 'Closed'
        :green
      when 'Will Not Fix'
        :green
    end
    "#{COLOR[color]}#{"%12s" % status.name}#{COLOR[:clear]}"
  end
end

class Issue < ActiveResource::Base
  include FormattedStatus
  self.site = $config[:site]
  self.user = $config[:user]
  self.password = $config[:password]

  def self.list
    return @@list if defined? @@list
    @@list = Dir.entries(DIRECTORY)
    2.times do @@list.shift end
    @@list
  end

  def change_status status_id, notes
    self.status_id = status_id
    self.notes = notes if notes
    self.save
    serialize!
  end

  def self.load id
    filename = "#{DIRECTORY}/#{id}"
    return nil unless File.exists? filename
    issue = Util.attributize YAML.load_file(filename)
    class << issue
      include FormattedStatus
    end
    issue
  end

  def serialize!
    json = JSON.parse to_json
    json = Util.fix_json json, 'issue'
    File.open("#{DIRECTORY}/#{id}", 'w') do |f|
      f.write(YAML.dump(json))
    end
  end
end

module Util
  def self.fix_json json, name
    json = json[name]
    json.keys.each do |key|
      json[key] = fix_json json[key], key if json[key].respond_to?(:has_key?) && json[key].has_key?(key)
    end
    json
  end

  def self.attributize hash
    return hash unless hash.is_a? Hash
    hash.keys.each do |key|
      (class << hash; self; end).class_eval do
        define_method key.to_sym do
          hash[key]
        end
      end
      Util.attributize hash[key]
    end
    hash
  end
end

case command
when 'open'
  ARGV.each do |id| IO.popen("open #{Issue.site}/issues/#{id}") end
when 'sync'
  (ARGV.empty?() ? Issue.list : ARGV).each do |id|
    Issue.find(id.to_i, :params => { :include => 'journals' }).serialize!
  end
when 'status'
  Issue.list.each do |id|
    issue   = Issue.load(id.to_i)
    issue ||= Issue.find(id.to_i, :params => { :include => 'journals' })
    puts "#{issue.id} #{"%2d" % (issue.respond_to?(:journals) ? issue.journals : []).length} #{"%6s" % issue.priority.name} #{issue.formatted_status} #{issue.subject}"
    issue.serialize! if issue.respond_to? :serialize!
  end
when 'add'
  ARGV.reject { |id| Issue.list.include? id }.each { |id| Issue.find(id.to_i).serialize! }
when 'remove'
  ARGV.each { |id| File.delete("#{DIRECTORY}/#{id}") }
when 'clean'
  Issue.list.each { |id| File.delete("#{DIRECTORY}/#{id}") if Issue.load(id).status.name == 'Closed' }
when 'clear'
  Issue.list.each { |id| File.delete("#{DIRECTORY}/#{id}") }
when 'fixed'
  id = ARGV[0].to_i
  pushed_upstream = IO.popen("git log --grep \"BUG.*#{id}:\" --oneline origin/master") do |f| f.readlines.length > 0 end
  puts "#{COLOR[:red]}WARNING#{COLOR[:clear]}: Change not pushed upstream. Don't forget again." unless pushed_upstream
  issue = Issue.find(id).change_status 3, ARGV[1]
when 'repro'
  issue = Issue.find(ARGV[0].to_i).change_status 1, ARGV[1]
when 'later'
  issue = Issue.find(ARGV[0].to_i).change_status 2, ARGV[1]
when 'nofix'
  issue = Issue.find(ARGV[0].to_i).change_status 6, ARGV[1]
end
